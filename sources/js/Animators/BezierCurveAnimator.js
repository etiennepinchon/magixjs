var BezierCurveAnimator, BezierCurveDefaults, UnitBezier,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

BezierCurveDefaults = {
  "linear": [0, 0, 1, 1],
  "ease": [.25, .1, .25, 1],
  "ease-in": [.42, 0, 1, 1],
  "ease-out": [0, 0, .58, 1],
  "ease-in-out": [.42, 0, .58, 1],
  "easein": [.42, 0, 1, 1],
  "easeout": [0, 0, .58, 1],
  "easeinout": [.42, 0, .58, 1]
};

BezierCurveAnimator = (function(_super) {
  __extends(BezierCurveAnimator, _super);

  function BezierCurveAnimator() {
    return BezierCurveAnimator.__super__.constructor.apply(this, arguments);
  }

  BezierCurveAnimator.prototype.setup = function(options) {
    if (Utils.isString(options) && BezierCurveDefaults.hasOwnProperty(options.toLowerCase())) {
      options = {
        values: BezierCurveDefaults[options.toLowerCase()]
      };
    }
    if (options.values && Utils.isString(options.values) && BezierCurveDefaults.hasOwnProperty(options.values.toLowerCase())) {
      options = {
        values: BezierCurveDefaults[options.values.toLowerCase()],
        time: options.time
      };
    }
    if (Utils.isArray(options) && options.length === 4) {
      options = {
        values: options
      };
    }
    this.options = Utils.defaults(options, {
      values: BezierCurveDefaults["ease-in-out"],
      time: 1,
      precision: 1 / 1000
    });
    return this._unitBezier = new UnitBezier(this.options.values[0], this.options.values[1], this.options.values[2], this.options.values[3], this._time = 0);
  };

  BezierCurveAnimator.prototype.next = function(delta) {
    this._time += delta;
    if (this.finished()) {
      return 1;
    }
    return this._unitBezier.solve(this._time / this.options.time);
  };

  BezierCurveAnimator.prototype.finished = function() {
    return this._time >= this.options.time - this.options.precision;
  };

  return BezierCurveAnimator;

})(Animator);

UnitBezier = (function() {
  UnitBezier.prototype.epsilon = 1e-6;

  function UnitBezier(p1x, p1y, p2x, p2y) {
    this.cx = 3.0 * p1x;
    this.bx = 3.0 * (p2x - p1x) - this.cx;
    this.ax = 1.0 - this.cx - this.bx;
    this.cy = 3.0 * p1y;
    this.by = 3.0 * (p2y - p1y) - this.cy;
    this.ay = 1.0 - this.cy - this.by;
  }

  UnitBezier.prototype.sampleCurveX = function(t) {
    return ((this.ax * t + this.bx) * t + this.cx) * t;
  };

  UnitBezier.prototype.sampleCurveY = function(t) {
    return ((this.ay * t + this.by) * t + this.cy) * t;
  };

  UnitBezier.prototype.sampleCurveDerivativeX = function(t) {
    return (3.0 * this.ax * t + 2.0 * this.bx) * t + this.cx;
  };

  UnitBezier.prototype.solveCurveX = function(x) {
    var d2, i, t0, t1, t2, x2;
    t2 = x;
    i = 0;
    while (i < 8) {
      x2 = this.sampleCurveX(t2) - x;
      if (Math.abs(x2) < this.epsilon) {
        return t2;
      }
      d2 = this.sampleCurveDerivativeX(t2);
      if (Math.abs(d2) < this.epsilon) {
        break;
      }
      t2 = t2 - x2 / d2;
      i++;
    }
    t0 = 0.0;
    t1 = 1.0;
    t2 = x;
    if (t2 < t0) {
      return t0;
    }
    if (t2 > t1) {
      return t1;
    }
    while (t0 < t1) {
      x2 = this.sampleCurveX(t2);
      if (Math.abs(x2 - x) < this.epsilon) {
        return t2;
      }
      if (x > x2) {
        t0 = t2;
      } else {
        t1 = t2;
      }
      t2 = (t1 - t0) * .5 + t0;
    }
    return t2;
  };

  UnitBezier.prototype.solve = function(x) {
    return this.sampleCurveY(this.solveCurveX(x));
  };

  return UnitBezier;

})();
